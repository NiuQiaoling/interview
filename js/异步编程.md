javascript是单线程的， 所谓单线程， 就是在程序执行时，所走的程序路径按照连续顺序排下来， 前面的必须处理好之后后面的才会执行。

那么js自上而下执行， 如果遇到一行需要执行好长时间， 后面的代码就不能正常执行， 很容易便出现了阻塞，又该如何解决呢？

好在javascript支持异步执行， 所谓异步执行是说， 程序在执行一个无法直接返回结果的代码段时， 例如数据请求，不用一直等服务器端返回数据后在执行下面的代码， 而是直接运行接下来的代码， 不管其他进程的状态， 当有消息返回时系统会通知进程进行处理， 从而提高执行效率。

那么， 单线程的javascript是怎么实现异步执行的呢，便是事件循环机制

既然javascript支持异步执行，那么怎么实现异步编程呢？常用的解决方案有以下几种：

## 回调函数

经常会遇到这样的情况， 一个操作需要依赖另一个操作， 便会出现多层回调的情况

    getData(a => {
        getData2((a, b) => {
            getData3((b, c) => {
                ...
            })
        })
    })

回调方式好在易于理解代码执行， 了解代码和代码之间的关系， 但是耦合性高，阅读性差，维护困难， 多个异步操作造成回调地狱

## Promise
ES6新增了Promise, 也是异步编程的一种解决方案

Promise是一个构造函数用来生成Promise实例

    var promise = new Promise(function(resolve, reject) {
        if(true) {
            resolve(data);
        } else {
            reject(error);
        }
    })
Promise构造函数接受一个函数作为参数， 函数的两个参数是resolve和reject。

resolve 函数的作用是将Promise对象状态从 ‘未完成’ 变成 ‘成功’

reject 函数的作用是将Promise对象状态从 ‘未完成’ 变成 ‘失败’

Promise实例生成后， 可以使用.then方法分别为resolve和reject两种状态提供回调函数


    promise.then(function(value) {
        console.log('成功');
    }, function(error) {
        console.log('失败');
    })
    也可以使用箭头函数
    pomise.then(
        (value) => {console.log('成功');},
        (error) => {console.log('失败');}
    )

注意点

    var p = new Promise((resolve, reject) => {
        resolve(1);
        console.log(2);
    })
    p.then(value => {
        console.log(value);
    });
    console.log(3); 
    // 2, 3, 1
执行顺序如下
- 主线程执行
- Promise在创建后直接执行
- then方法指定的回调函数是异步任务， 推入事件队列中， 等待执行
- 继续执行主线程中的同步任务，console.log(3)
- 主线程空闲， 从事件队列中取异步任务执行， then方法开始执行
- 执行完毕

1. **Promise在创建后直接执行**
2. **调用resolve或reject并不会终结 Promise 的参数函数的执行**
3. **resolve总是在当前脚本所有同步任务执行完成后才会执行，总是最后输出**




### Promise.prototype.then()
then方法接受两个回调函数作为参数， 第二个参数是可选的

- 第一个是由pending >> redolve时的回调处理函数
- 第二个是由pending >> reject 时的回调处理函数（可选）

### Promise.prototype.catch()
用于指定发生错误时的回调函数

    pomise.then(
        (value) => {console.log('成功');}
    ).catch(error => {
        console.log(error);
    })
### Promise.prototype.finally()
用于指定无论最后Promise对象状态是什么， 都会执行finally内的操作

    pomise.then(
        (value) => {console.log('成功');}
    ).catch(error => {
        console.log(error);
    }).finally(() => {
        ...
    })
### Promise.all()
用于将多个Promise实例包装成一个新的Promise实例, 接收一个数组作为参数

    var p = promise.all([p1, p2, p3]);

p的状态由p1、p2、p3决定，分成两种情况。

（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。

（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
    
### Promise.race()
用于将多个Promise实例包装成一个新的Promise实例, 接收一个数组作为参数

    var p = promise.race([p1, p2, p3]);

只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。
### Promise.resolve()
将现有对象转为Promise对象

    const jsPromise = Promise.resolve($.ajax('/whatever.json'));

### Promise.reject() 

Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。

    const p = Promise.reject('出错了');
    // 等同于
    const p = new Promise((resolve, reject) => reject('出错了'));

    p.then(null, function (s) {
        console.log(s)
    });
    // 出错了